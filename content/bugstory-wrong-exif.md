Title: Вот это поворот...
Date: 2015-09-06 15:00
Modified: 2015-09-06 15:00
Category: Bugstory
Tags: python, exif, bug, magic, crop, jpg, thumbnail, pil, image, lena
Image: /media/md-headers/pelican-md.png
Summary:
    Однажды столкнулся с магическим багом, причину возникновения которого,
    неудавалось отыскать почти на протяжении месяца. Да что там причину,
    его даже воспроизвести никак не удавалось. Заказчик постоянно жаловался
    что изображения обрезаются неправильно, да при том ещё непредсказуемо
    поворачиваются...

Однажды столкнулся с магическим багом, причину возникновения которого,
неудавалось отыскать почти на протяжении месяца. Да что там причину,
его даже воспроизвести никак не удавалось. Заказчик постоянно жаловался
что изображения обрезаются неправильно, да при том ещё непредсказуемо
поворачиваются...

##Неуловимая ошибка

Суть проекта заключалась в том, что пользователи выкладывают фотографии,
сопровождая их коротенькими историями, далее модераторы проверяют контент
на соответствие тематике ресурса, обрезают фотографии по необходимому
соотношению сторон и публикуют эти истории.

Буквально с первых же дней выхода проекта в продакшн, начали поступать жалобы
от модераторов. Жаловались на то, что фотографии обрезаются не так как это
ожидается, иногда появляются черные полоски, иногда фотографии внезапно
поворачиваются, иногда вообще не происходит каких либо изменений после обрезки.

Для обрезки изображений использовалась библиотека
[django-image-cropping](https://pypi.python.org/pypi/django-image-cropping),
которая позволяет в админке джанго обрезать изображения при помощи `jQuery`
плагина [Jcrop](http://deepliquid.com/content/Jcrop.html).

##Ложные обвинения

Поскольку ошибку никак не удавалось воспроизвести, стали полагать, что причина
прячется где то в клиентской части. За две с половиной недели поиска ошибки,
были перепробованы чуть менее чем все комбинации различных браузеров и
операционных систем, включая устаревшие версии браузеров. Но воспроизвести
ошибку все никак не удавалось.

Тем неменее, усердное тестирование обрезки изображения в различных браузерах
выявило сопутствующую ошибку. От браузера, кстати, независящую. Продакшен
сервер был оптимизирован под большое количество посетителей. Сам проект
представлял из себя регенерируемый, статический сайт, кешированный `nginx`ом;
небольшое `api` для добавления и поиска историй; и административный интерфейс
для премодерации историй и перегенерации статического контента.

Так получилось, что `nginx` слишком усердно справлялся с кешированием,
и достаточно часто после обрезки изображения в админке показывал "старое"
(не обрезанное изображение), после чего модератор снова и снова "обрезал"
картинку, а в результате исходное изображение резалось по несуществующим
координатам. Соответственно на выходе получалось изкромсаное изображение с
черными полосками и когда кеш обновлялся то это становилось заметно.

Данную ошибку с кеширование легко исправить введя случайный `GET` параметр в
адресе изображения перед выводом его в админке.
Примерно так:

```python
from random import randint
rand_url = lambda url: '{url}?{num}'.format(url=url, num=randint(10000, 99999))

# ...

return {
    # ...
    'data-thumbnail-url': rand_url(thumbnail(image).url)
    # ...
}
```

Вследствии чего, проблема отображения "старого" изображения после обрезки
исчезла. В админке выводился следующий `html` код отображения изображения:

```html

```

Ошибка найдена и ликвидирована. Больше повторятся не должна.
Можно торжествовать победу.

##Начинаем сначала

Буквально через неделю, после сабмита изменений в продакшн, от модераторов
вновь поступила жалоба на некорректную обрезку изображения. К счастью,
на этот раз они явно указали на каком именно изображении воспроизводится
некорректная обрезка и переслали данное изображение по электронной почте.

Открыв письмо, я открыл картинку в новой вкладке и сохранил её. Начал
тестировать в `vagrant`е -- ошибка не воспроизводится, изображение обрезается
как нужно, ничего не поворачивается и не возникают черные полосы. Проверил
эту же картинку на продакшн сервере -- не воспроизводится.
Хитрость оказалась в том, что нужно было картинку именно "скачать", а не
"сохранить" из письма. Получив исходное изображение, ошибка стала регулярно
воспроизводится.

###Exif метаданные

Поскольку существенную разницу поведения изображения вызывало "сохранении"
и "скачивание", а так же -- тот факт, что после сохранения изображения в
графическом редакторе ошибка прекращала воспроизводится. Натолкнуло на мысль,
о том, что в данном изображении содержится дополнительная информация,
которая при сохранении теряется.

В графических изображениях дополнительную метаинформацию можно сохранять
в формате [EXIF](http://www.exif.org/). Где среди прочего может содержаться
информация об ориентации изображения. Выведя `exif` данного изображения,
сразу стало понятно почему ошибка воспроизводится.  

```python
>>> from PIL import Image
>>> from PIL.ExifTags import TAGS
>>> 
>>> im = Image.open('photo.jpg')
>>> exif = im._getexif()
>>> 
>>> data = {}
>>> 
>>> for tag, value in exif.items():
...   decoded = TAGS.get(tag, tag)
...   data[decoded] = value
... 
>>>
>>> import pprint
>>> pp = pprint.PrettyPrinter(indent=4)
>>>
>>> pp.pprint(data)
{   'ApertureValue': (4281, 1441),
    'ColorSpace': 1,
    'ComponentsConfiguration': '\x01\x02\x03\x00',
    'DateTime': u'2012:09:08 18:10:40',
    'DateTimeDigitized': u'2012:09:08 18:10:40',
    'DateTimeOriginal': u'2012:09:08 18:10:40',
    'ExifImageHeight': 1536,
    'ExifImageWidth': 2048,
    'ExifOffset': 206,
    'ExifVersion': '0221',
    'ExposureMode': 0,
    'ExposureProgram': 2,
    'ExposureTime': (1, 15),
    'FNumber': (14, 5),
    'Flash': 32,
    'FlashPixVersion': '0100',
    'FocalLength': (77, 20),
    'GPSInfo': {   1: u'N',
                   2: ((**, **), (****, ****), (*, *)),
                   3: u'E',
                   4: ((**, **), (****, ****), (*, *)),
                   5: '\x00',
                   6: (25453, 182),
                   7: ((11, 1), (10, 1), (3588, 100)),
                   16: u'M',
                   17: (44274, 191)},
    'ISOSpeedRatings': 100,
    'Make': u'Apple',
    'MeteringMode': 1,
    'Model': u'iPhone 3GS',
    'Orientation': 6,
    'ResolutionUnit': 2,
    'SceneCaptureType': 0,
    'SensingMethod': 2,
    'Sharpness': 1,
    'Software': u'5.1.1',
    'SubjectLocation': (1023, 767, 614, 614),
    'WhiteBalance': 0,
    'XResolution': (72, 1),
    'YCbCrPositioning': 1,
    'YResolution': (72, 1)}
>>>
```

Как видно из `exif` данных, изображением является фотография сделанная на
`iPhone 3GS` в сентябре 2012 года. Но это не принципиально,
главным является информация об ориентации изображения в пространстве:
`Orientation: 6`.

`Exif Orientation` тег описывает ориентацию изображения в пространстве
используя следующие правила:

```
  1        2       3      4         5            6           7          8

######  ######      ##  ##      ##########  ##                  ##  ##########
##          ##      ##  ##      ##  ##      ##  ##          ##  ##      ##  ##
####      ####    ####  ####    ##          ##########  ##########          ##
##          ##      ##  ##
##          ##  ######  ######
```

Наглядно на примере фотокамеры, могут возникать 4 варианта тега ориентации:

![exif orient](/media/wrong-exif/orient.gif){.center}

###PIL & Exif

При сохранении изображения с помощью `PIL` все метаданные `exif` стираются,
поэтому сохраненная картинка уже не поворачивается а остается такая как есть,
тоесть "непредсказуемо поворачиваются".

```python
>>> # ...
>>> im.save('saved.jpg')
>>> im_saved = Image.open('saved.jpg')
>>> exif = im_saved._getexif()
>>> exif is None
True
>>>
```
